from datetime import datetime, timedelta
import numpy as np
import pandas as pd
import queue


from abc import ABCMeta, abstractmethod

from event import SignalEvent
from queue import Queue


class Strategy(object):
    """
    Strategy is an abstract base class providing an interface for
    all subsequent (inherited) strategy handling objects.

    The goal of a (derived) Strategy object is to generate Signal
    objects for particular symbols based on the inputs of Bars 
    (OLHCVI) generated by a DataHandler object.

    This is designed to work both with historic and live data as
    the Strategy object is agnostic to the data source,
    since it obtains the bar tuples from a queue object.
    """

    __metaclass__ = ABCMeta
    
    @abstractmethod
    def calculate_signals(self):
        """
        Provides the mechanisms to calculate the list of signals.
        """
        raise NotImplementedError("Should implement calculate_signals()")
    


class BuyAndHoldStrategy(Strategy):
    """
    This is an extremely simple strategy that goes LONG all of the 
    symbols as soon as a bar is received. It will never exit a position.

    It is primarily used as a testing mechanism for the Strategy class
    as well as a benchmark upon which to compare other strategies.
    """

    def __init__(self, market_data, events):
        """
        Initialises the buy and hold strategy.

        Parameters:
        bars - The DataHandler object that provides bar information
        events - The Event Queue object.
        """
        self.market_data = market_data
        self.markets = self.market_data.markets
        self.events = events
        self.signals = {m:[]for m in self.markets}

        # Once buy & hold signal is given, these are set to True
        self.bought = self._calculate_initial_bought()
    
    def calculate_signals(self, event):
        """
        For "Buy and Hold" we generate a single signal per symbol
        and then no additional signals. This means we are 
        constantly long the market from the date of strategy
        initialisation.

        Parameters
        event - A MarketEvent object. 
        """
        if event.type == 'MARKET':
            for market in self.markets:
                snapshot = self.market_data.get_latest_market_data(market, N=1)
                if snapshot is not None:
                    # Check the past 6 hours 
                    window = 6
                    time = snapshot.name

                    prev_trades = self.market_data.market_data[market].ix[time-timedelta(hours=window):time]
                    
                    rolling_mean = prev_trades.rate['mean'].rolling(window=window, min_periods=1).mean()
                    
                    buy_signal = rolling_mean.ix[time] < snapshot.rate['mean']
                    
                    if buy_signal:
                        signal_type = 'LONG'
                    else:
                        signal_type = 'SHORT'
                        
                    self.events.put(SignalEvent(market, time, signal_type, snapshot, strength=1))
                    
                    self.signals[market].append({
                            'datetime': time,
                            'signal_type': signal_type
                        })
                    

        
        
    def _calculate_initial_bought(self):
        """
        Adds keys to the bought dictionary for all symbols
        and sets them to False.
        """
        bought = {}
        for m in self.markets:
            bought[m] = False
        return bought